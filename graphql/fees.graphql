# Object Type #
type Fee {
    id: ID!
    name: String!
    description: String
    # TODO: Replace Programme and Level by Group
    # So that fees may be billed to group of people
    programme: Programme! @belongsTo
    level: Int!
    amountPayable: Float!
    # TODO: Implement this
    paymentCycle: PaymentCycle
    paymentMethod: PaymentMethod
    created_at: DateTime!
    updated_at: DateTime!
}

# Create Input Type #
input FeeCreateInput {
    name: String!
    description: String @trim
    # TODO: Replace Programme and Level by Group
    # So that fees may be billed to group of people
    programme: NestedProgrammeCreateInput!
    level: Int!
    amountPayable: Float!
    paymentCycle: PaymentCycle
    paymentMethod: PaymentMethod
}

# Update Input Type #
input FeeUpdateInput {
    id: ID!
    name: String!
    description: String @trim
    # TODO: Replace Programme and Level by Group
    # So that fees may be billed to group of people
    programme: NestedProgrammeUpdateInput
    level: Int
    amountPayable: Float
    paymentCycle: PaymentCycle
    paymentMethod: PaymentMethod
}

# Upsert Input Type #
input FeeUpsertInput {
    id: ID!
    name: String!
    description: String @trim
    # TODO: Replace Programme and Level by Group
    # So that fees may be billed to group of people
    programme: NestedProgrammeUpsertInput!
    level: Int!
    amountPayable: Float!
    paymentCycle: PaymentCycle
    paymentMethod: PaymentMethod
}

# Nested Single  Mutations
# Nested Single Create Input #
input NestedFeeCreateInput {
    create: FeeCreateInput
    upsert: FeeUpsertInput
    connect: ID
    sync: ID
}

# Nested Single Update Input #
input NestedFeeUpdateInput {
    create: FeeCreateInput
    update: FeeUpdateInput
    upsert: FeeUpsertInput
    connect: ID
    sync: ID
    syncWithoutDetaching: ID
    delete: ID
    disconnect: ID
}

# Nested Single Upsert Input #
input NestedFeeUpsertInput {
    create: FeeCreateInput
    upsert: FeeUpsertInput
    connect: ID
    sync: ID
}

# List Nested Mutations
# Nested List Create Input #
input NestedFeesCreateInput {
    create: [FeeCreateInput!]
    upsert: [FeeUpsertInput!]
    connect: [ID!]
    sync: [ID!]
}

# Nested List Update Input #
input NestedFeesUpdateInput {
    create: [FeeCreateInput!]
    update: [FeeUpdateInput!]
    upsert: [FeeUpsertInput!]
    connect: [ID!]
    sync: [ID!]
    syncWithoutDetaching: [ID!]
    delete: [ID!]
    disconnect: [ID!]
}

# Nested List Upsert Input #
input NestedFeesUpsertInput {
    create: [FeeCreateInput!]
    upsert: [FeeUpsertInput!]
    connect: [ID!]
    sync: [ID!]
}

enum PaymentCycle {
    ANNUAL @enum(value: "Annual")
    BI_ANNUAL @enum(value: "Bi-Annual")
    TRI_ANNUAL @enum(value: "Tri-Annual")
    QUARTERLY @enum(value: "Quarterly")
    MONTHLY @enum(value: "Monthly")
    WEEKLY @enum(value: "Weekly")
    DIALY @enum(value: "Daily")
    PAY_AS_YOU_GO @enum(value: "Pay as you go")
    ONE_TIME @enum(value: "One Time")
}

enum PaymentMethod {
    TRANSFLOW @enum(value: "Transflow")
    BANKERS_DRAFT @enum(value: "Bankers Draft")
    CHEQUE @enum(value: "Cheque")
    MOBILE_TRANSFER @enum(value: "Mobile Transfer")
    CASH_DEPOSIT @enum(value: "Cash Deposit")
    CASH_PAYMENT @enum(value: "Cash payment")
}

extend type Query {
    fee(id: ID! @eq): Fee @find
    fees: [Fee] @all
}

extend type Mutation {
    createFee(input: FeeCreateInput! @spread): Fee @create
    updateFee(input: FeeUpdateInput! @spread): Fee @update
    upsertFee(input: FeeUpsertInput! @spread): Fee @upsert
    deleteFee(id: ID! @eq): Fee @delete
}
