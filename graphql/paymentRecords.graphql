# Object Type
type PaymentRecord {
    id: ID!
    receiptImage: String
    transactionDate: DateTime!
    transactionID: String!
    bank: Bank!
    amountPaid: Float!
    paidBy: Student! @belongsTo
    # TODO: Implement this
    # recordedBy: User! @belongsTo
    created_at: DateTime!
    updated_at: DateTime!
}

# Create Input Type
input PaymentRecordCreateInput {
    receiptImage: String @trim
    transactionDate: DateTime!
    transactionID: String! @trim
    bank: Bank!
    amountPaid: Float!
    paidBy: NestedStudentCreateInput!
    # recordedBy: UserOperation!
}

# Update Input Type
input PaymentRecordUpdateInput {
    id: ID!
    receiptImage: String @trim
    transactionDate: DateTime
    transactionID: String @trim
    bank: Bank
    amountPaid: Float
    paidBy: NestedStudentUpdateInput
    # recordedBy: UserOperation
}

# Upsert Input Type #
input PaymentRecordUpsertInput {
    id: ID!
    receiptImage: String @trim
    transactionDate: DateTime!
    transactionID:student
    bank: Bank!
    amountPaid: Float!
    paidBy: NestedStudentUpsertInput!
    # recordedBy: UserOperation!
}

enum Bank {
    GCB @enum(value: 0)
    ADB @enum(value: 1)
    ZENITH @enum(value: 2)
    CBG @enum(value: 3)
    NIB @enum(value: 4)
    PRUDENTIAL @enum(value: 5)
}


# Nested Single  Mutations
# Nested Single Create Input #
input NestedPaymentRecordCreateInput {
    create: PaymentRecordCreateInput
    upsert: PaymentRecordUpsertInput
    connect: ID
    sync: ID
}

# Nested Single Update Input #
input NestedPaymentRecordUpdateInput {
    create: PaymentRecordCreateInput
    update: PaymentRecordUpdateInput
    upsert: PaymentRecordUpsertInput
    connect: ID
    sync: ID
    syncWithoutDetaching: ID
    delete: ID
    disconnect: ID
}

# Nested Single Upsert Input #
input NestedPaymentRecordUpsertInput {
    create: PaymentRecordCreateInput
    upsert: PaymentRecordUpsertInput
    connect: ID
    sync: ID
}

# List Nested Mutations
# Nested List Create Input #
input NestedPaymentRecordsCreateInput {
    create: [PaymentRecordCreateInput!]
    upsert: [PaymentRecordUpsertInput!]
    connect: [ID!]
    sync: [ID!]
}

# Nested List Update Input #
input NestedPaymentRecordsUpdateInput {
    create: [PaymentRecordCreateInput!]
    update: [PaymentRecordUpdateInput!]
    upsert: [PaymentRecordUpsertInput!]
    connect: [ID!]
    sync: [ID!]
    syncWithoutDetaching: [ID!]
    delete: [ID!]
    disconnect: [ID!]
}

# Nested List Upsert Input #
input NestedPaymentRecordsUpsertInput {
    create: [PaymentRecordCreateInput!]
    upsert: [PaymentRecordUpsertInput!]
    connect: [ID!]
    sync: [ID!]
}

# Query
extend type Query {
    paymentRecord(id: ID! @eq): PaymentRecord @find
    paymentRecords: [PaymentRecord!] @all
}

# Mutation
extend type Mutation {
    createPaymentRecord(
        input: PaymentRecordCreateInput! @spread
    ): PaymentRecord @create
    updatePaymentRecord(
        input: PaymentRecordUpdateInput! @spread
    ): PaymentRecord @update
    upsertPaymentRecord(
        input: PaymentRecordUpsertInput! @spread
    ): PaymentRecord @upsert
    deletePaymentRecord(id: ID! @eq): PaymentRecord @delete
}
